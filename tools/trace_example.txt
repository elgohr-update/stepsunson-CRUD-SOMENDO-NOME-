Demonstrations of trace.


trace probes functions you specify and displays trace messages if a particular
condition is met. You can control the message format to display function
arguments and return values.

For example, suppose you want to trace all commands being exec'd across the
system:

# trace 'sys_execve "%s", arg1'
PID    COMM         FUNC             -
4402   bash         sys_execve       /usr/bin/man
4411   man          sys_execve       /usr/local/bin/less
4411   man          sys_execve       /usr/bin/less
4410   man          sys_execve       /usr/local/bin/nroff
4410   man          sys_execve       /usr/bin/nroff
4409   man          sys_execve       /usr/local/bin/tbl
4409   man          sys_execve       /usr/bin/tbl
4408   man          sys_execve       /usr/local/bin/preconv
4408   man          sys_execve       /usr/bin/preconv
4415   nroff        sys_execve       /usr/bin/locale
4416   nroff        sys_execve       /usr/bin/groff
4418   groff        sys_execve       /usr/bin/grotty
4417   groff        sys_execve       /usr/bin/troff
^C

The ::sys_execve syntax specifies that you want an entry probe (which is the
default), in a kernel function (which is the default) called sys_execve. Next,
the format string to print is simply "%s", which prints a string. Finally, the
value to print is the first argument to the sys_execve function, which happens
to be the command that is exec'd. The above trace was generated by executing
"man ls" in a separate shell. As you see, man executes a number of additional
programs to finally display the man page.

Next, suppose you are looking for large reads across the system. Let's trace
the read system call and inspect the third argument, which is the number of
bytes to be read:

# trace 'sys_read (arg3 > 20000) "read %d bytes", arg3'
PID    COMM         FUNC             -
4490   dd           sys_read         read 1048576 bytes
4490   dd           sys_read         read 1048576 bytes
4490   dd           sys_read         read 1048576 bytes
4490   dd           sys_read         read 1048576 bytes
^C

During the trace, I executed "dd if=/dev/zero of=/dev/null bs=1M count=4".
The individual reads are visible, with the custom format message printed for
each read. The parenthesized expression "(arg3 > 20000)" is a filter that is
evaluated for each invocation of the probe before printing anything.

Event message filter is useful while you only interesting the specific event.
Like the program open thousands file and you only want to see the "temp" file
and print stack.

# trace 'do_sys_open "%s", arg2@user' -UK -f temp
PID     TID     COMM            FUNC             -
9557    9557    a.out           do_sys_open      temp.1
        do_sys_open+0x1 [kernel]
        do_syscall_64+0x5b [kernel]
        entry_SYSCALL_64_after_hwframe+0x44 [kernel]
        __open_nocancel+0x7 [libc-2.17.so]
        __libc_start_main+0xf5 [libc-2.17.so]
9558    9558    a.out           do_sys_open      temp.2
        do_sys_open+0x1 [kernel]
        do_syscall_64+0x5b [kernel]
        entry_SYSCALL_64_after_hwframe+0x44 [kernel]
        __open_nocancel+0x7 [libc-2.17.so]
        __libc_start_main+0xf5 [libc-2.17.so]

Process name filter is porting from tools/opensnoop

# trace 'do_sys_open "%s", arg2@user' -UK -n out
PID     TID     COMM            FUNC             -
9557    9557    a.out           do_sys_open      temp.1
        do_sys_open+0x1 [kernel]
        do_syscall_64+0x5b [kernel]
        entry_SYSCALL_64_after_